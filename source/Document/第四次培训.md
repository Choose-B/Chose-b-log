# 第四次培训

## 匿名上位机 / VOFA+上位机的添加

### 下载

- 匿名官网下载：[匿名产品资料:资料下载链接汇总-匿名科创](https://www.anotc.com/wiki/%E5%8C%BF%E5%90%8D%E4%BA%A7%E5%93%81%E8%B5%84%E6%96%99/%E8%B5%84%E6%96%99%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5%E6%B1%87%E6%80%BB)
- vofa+官网下载：[代码配酒，bug没有-VOFA+](https://www.vofa.plus/)
  
### 代码添加

- 创建头文件并添加：

```c
    #ifndef _ANO_VOFA_H_
    #define _ANO_VOFA_H_

    #include "stm32h7xx_hal.h"
    // #include "cmsis_os.h"
    // #include "driver_usart.h"
    #include "usart.h"

    /*-------------------------------匿名上位机---------------------------------*/
    #define BYTE0(dwTemp) (*(char *)(&dwTemp))
    #define BYTE1(dwTemp) (*((char *)(&dwTemp) + 1))
    #define BYTE2(dwTemp) (*((char *)(&dwTemp) + 2))
    #define BYTE3(dwTemp) (*((char *)(&dwTemp) + 3))

    void ANO_Send_Up_Computer(UART_HandleTypeDef *uartx,
                              int16_t user1, int16_t user2, int16_t user3, int16_t user4, int16_t user5, int16_t user6);
    void UsartDmaPrintf(UART_HandleTypeDef *uartx, const char *format, ...);
    // uint8_t vofa_Callback(uint8_t *recBuffer, uint16_t len);
    #ifdef _CMSIS_OS_H // 使用cmsis_os.h的代码的串口结构体类型是UART_RxBuffer_t，没有用RTOS的是老版代码，为了兼容性，添加此宏定义
    extern UART_RxBuffer_t uart5_buffer;
    #else // 使用UART_RxBuffer则将#include "cmsis_os.h"注释掉
    // extern UART_RxBuffer uart5_buffer;
    #endif
    extern uint8_t Usart5_TxBuffer_ANO[20] __attribute__((at(0x24020000)));   // 匿名上位机
    extern uint8_t Usart5_TxBuffer_Vofa[128] __attribute__((at(0x24020200))); // VOFA+

    #endif

```

- 创建源文件并添加：

```c
    #include "ano_vofa.h"
    #include <stdarg.h>
    #include <stdio.h>
    uint8_t Usart5_TxBuffer_ANO[20];
    uint8_t Usart5_TxBuffer_Vofa[128];

    /*-------------------------------匿名上位机---------------------------------*/
    void ANO_Send_Up_Computer(UART_HandleTypeDef *uartx, int16_t user1, int16_t user2, int16_t user3, int16_t user4, int16_t user5, int16_t user6)
    {
        uint8_t _cnt                = 0;
        Usart5_TxBuffer_ANO[_cnt++] = 0xAA;
        Usart5_TxBuffer_ANO[_cnt++] = 0xFF;
        Usart5_TxBuffer_ANO[_cnt++] = 0xF1;
        Usart5_TxBuffer_ANO[_cnt++] = 12;

        Usart5_TxBuffer_ANO[_cnt++] = BYTE0(user1);
        Usart5_TxBuffer_ANO[_cnt++] = BYTE1(user1);

        Usart5_TxBuffer_ANO[_cnt++] = BYTE0(user2);
        Usart5_TxBuffer_ANO[_cnt++] = BYTE1(user2);

        Usart5_TxBuffer_ANO[_cnt++] = BYTE0(user3);
        Usart5_TxBuffer_ANO[_cnt++] = BYTE1(user3);

        Usart5_TxBuffer_ANO[_cnt++] = BYTE0(user4);
        Usart5_TxBuffer_ANO[_cnt++] = BYTE1(user4);

        Usart5_TxBuffer_ANO[_cnt++] = BYTE0(user5);
        Usart5_TxBuffer_ANO[_cnt++] = BYTE1(user5);

        Usart5_TxBuffer_ANO[_cnt++] = BYTE0(user6);
        Usart5_TxBuffer_ANO[_cnt++] = BYTE1(user6);

        uint8_t sc = 0;
        uint8_t ac = 0;

        for (uint8_t i = 0; i < (Usart5_TxBuffer_ANO[3] + 4); i++) {
            sc += Usart5_TxBuffer_ANO[i];
            ac += sc;
        }
        Usart5_TxBuffer_ANO[_cnt++] = sc;
        Usart5_TxBuffer_ANO[_cnt++] = ac;

        HAL_UART_Transmit_DMA(uartx, Usart5_TxBuffer_ANO, _cnt);
    }
    /*------------------------------- VOFA+ ---------------------------------*/
    void UsartDmaPrintf(UART_HandleTypeDef *uartx, const char*format, ...)
    {
        uint16_t len;
        va_list args;
        va_start(args, format);
        len = vsnprintf((char *)Usart5_TxBuffer_Vofa, sizeof(Usart5_TxBuffer_Vofa) + 1, (char*)format, args);
        va_end(args);
        HAL_UART_Transmit_DMA(uartx, Usart5_TxBuffer_Vofa, len);
    }

```

## PID算法

- PID算法公式：
  - 连续：

    $$
    u(t)=K_p e(t)+K_i \int_{0}^{t} e(t)dt+K_d \frac{de(t)}{dt}
    $$

  - 离散：

    \[  
    u(k) = K_p e(k) + K_i \sum_{j=0}^{k} e(j) + K_d [e(k) - e(k-1)]  
    \]

- $e(t)$：误差 = 设定值 - 实际值
- $K_p$：比例增益
- $K_i$：积分增益
- $K_d$：微分增益
- $u(t)$：控制量

- PID算法的特点：
  - 快速响应：当误差积分到一定程度时，积分增益将起到稳定作用，使得输出值快速响应。
  - 稳定性：当误差积分到一定程度时，积分增益将起到稳定作用，使得输出值稳定。
  - 阻尼作用：当误差积分到一定程度时，积分增益将起到阻尼作用，使得输出值减小。
  - 输出限制：当输出值超过限制时，输出值将被限制。
- 代码实现(**需要自己动手写代码，大体就是下面四个步骤**)：
  - 定义PID结构体：
  - 初始化PID结构体：
  - PID算法：
  - 输出限制：
  